#include <stdio.h>
#include "pico/stdlib.h"
#include "hardware/i2c.h"
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"

#define LIS3DH_ADDR 0x19
#define I2C_PORT i2c0
#define SDA_PIN 8
#define SCL_PIN 9
#define LED_PIN 3
#define LED2_PIN 4

QueueHandle_t z_accel_queue;

void lis3dh_init() {
    // Ustawienie akcelerometru na 100Hz i włączenie wszystkich osi
    uint8_t ctrl_reg1[] = {0x20, 0b01010111}; // 100Hz, wszystkie osie włączone
    i2c_write_blocking(I2C_PORT, LIS3DH_ADDR, ctrl_reg1, 2, false);
    
    //uint8_t ctrl_reg4[] = {0x23, 0b00000000}; //for +/-2g
    //uint8_t ctrl_reg4[] = {0x23, 0b00100000}; // +/-4g sensitivity
    //uint8_t ctrl_reg4[] = {0x23, 0b00010000}; // +/-8g
    uint8_t ctrl_reg4[] = {0x23, 0b00110000}; // +/-16g
    i2c_write_blocking(I2C_PORT, LIS3DH_ADDR, ctrl_reg4, 2, false);
}

int16_t read_z_axis() {
    uint8_t reg = 0x2C | 0x80; // OUT_Z_L, auto-increment
    uint8_t data[2];
    i2c_write_blocking(I2C_PORT, LIS3DH_ADDR, &reg, 1, true);
    i2c_read_blocking(I2C_PORT, LIS3DH_ADDR, data, 2, false);
    return (int16_t)(data[1] << 8 | data[0]);
}

void task_read_accel(void *params) {
    lis3dh_init();
    uint8_t who_am_i_reg = 0x0F;
    
    uint8_t who_am_i;
    i2c_write_blocking(I2C_PORT, LIS3DH_ADDR, &who_am_i_reg, 1, true);
    i2c_read_blocking(I2C_PORT, LIS3DH_ADDR, &who_am_i, 1, false);
    printf("WHO_AM_I = 0x%02X\n", who_am_i);

    // Odczytaj CTRL_REG1
    uint8_t ctrl_reg1 = 0x20;
    uint8_t ctrl_val;
    i2c_write_blocking(I2C_PORT, LIS3DH_ADDR, &ctrl_reg1, 1, true);
    i2c_read_blocking(I2C_PORT, LIS3DH_ADDR, &ctrl_val, 1, false);
    printf("CTRL_REG1 = 0x%02X\n", ctrl_val); // Expected :0x57

    while (1) {
        int16_t z = read_z_axis();
        float z_g = z *0.00003f; // 16g sensitivity
        //printf("Z-axis: %d, Z_g: %.2f\n", z, z_g);
        //printf("Z-axis: %d\n", z);
        xQueueSend(z_accel_queue, &z, 0);
        vTaskDelay(pdMS_TO_TICKS(5)); // ~200Hz
    }
}

void task_detect_tap(void *params) {
    int16_t z = 0;
    int16_t last = 0;
    int tap_count = 0;
    uint32_t last_tap_time = 0;

    while (1) {
        if (xQueueReceive(z_accel_queue, &z, portMAX_DELAY)) {
            
            int16_t delta = z - last;
            //printf("Delta Z: %d\n", z);;

            if (delta > 800 || delta < -800) {  // Threshold 
                uint32_t current_time = xTaskGetTickCount();
                
                if (tap_count == 1 && (current_time - last_tap_time) <= pdMS_TO_TICKS(500)) {
                    printf("Detected 2 taps!\n");
                    gpio_put(LED_PIN, 1);
                    vTaskDelay(pdMS_TO_TICKS(200));
                    gpio_put(LED_PIN, 0);
                    tap_count = 0;
                } 
                else if (tap_count == 0) {
                    printf("Detected 1 tap!\n");
                   gpio_put(LED2_PIN, 1);
                   vTaskDelay(pdMS_TO_TICKS(200));
                   gpio_put(LED2_PIN, 0);
                    tap_count = 1;
                } 
                else {
                  
                    tap_count = 0;
                }
                
                last_tap_time = current_time; 
            }

            last = z;
        }
    }
}



void i2c_scan() {
    printf("Scanning I2C bus...\n");
    for (uint8_t addr = 0x08; addr <= 0x77; addr++) {
        uint8_t dummy;
        int result = i2c_read_blocking(I2C_PORT, addr, &dummy, 1, false);
        if (result >= 0) {
            printf("Device found at 0x%02X\n", addr);
        }
    }
}

int main() {
    stdio_init_all();
    gpio_init(LED_PIN);
    gpio_set_dir(LED_PIN, GPIO_OUT);
    gpio_init(LED2_PIN);  // Inicjalizacja pinu LED2
    gpio_set_dir(LED2_PIN, GPIO_OUT);  // Ustawienie LED2 jako wyjście
    

    i2c_init(I2C_PORT, 400 * 1000);
    gpio_set_function(SDA_PIN, GPIO_FUNC_I2C);
    gpio_set_function(SCL_PIN, GPIO_FUNC_I2C);
    gpio_pull_up(SDA_PIN);
    gpio_pull_up(SCL_PIN);

    i2c_scan();

    z_accel_queue = xQueueCreate(32, sizeof(int16_t));

    xTaskCreate(task_read_accel, "ReadAccel", 256, NULL, 1, NULL);
    xTaskCreate(task_detect_tap, "DetectTap", 256, NULL, 1, NULL);

    vTaskStartScheduler();

    while (1);
    return 0;
}
